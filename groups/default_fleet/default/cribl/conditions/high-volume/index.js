exports.name="High Data Volume";exports.type="metric";exports.category="sources";let name;let __workerGroup;let timeWindow;let dataVolumeBytes;let dataVolume;exports.init=e=>{const t=e.conf||{};({name,__workerGroup,timeWindow,dataVolume}=t);timeWindow=timeWindow||"60s";dataVolume=dataVolume||"1TB";dataVolumeBytes=C.util.parseMemoryStringToBytes(dataVolume,(e=>{throw e}))};exports.build=()=>{let e=`(_metric === 'total.in_bytes' || _metric === 'health.inputs') && input === '${name}'`;let t=`'Source ${name} traffic volume greater than ${dataVolume} in ${timeWindow}'`;const a=[{name:"input",value:`'${name}'`},{name:"_metric",value:`'total.in_bytes'`}];if(__workerGroup){e=`(${e}) && __worker_group === '${__workerGroup}'`;t=`'Source ${name} in group ${__workerGroup} traffic volume greater than ${dataVolume} in ${timeWindow}'`}a.push({name:"_raw",value:t});return{filter:e,pipeline:{conf:{functions:[{id:"aggregation",conf:{timeWindow,dataVolume,aggregations:["sum(_value).where(_metric==='total.in_bytes').as(bytes)","perc(95, _value).where(_metric==='health.inputs').as(health)"],lagTolerance:"20s",idleTimeLimit:"20s"}},{id:"drop",filter:`bytes < ${dataVolumeBytes} || bytes === undefined`},{id:"eval",conf:{add:a}}]}}}};