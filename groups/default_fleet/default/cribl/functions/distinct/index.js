exports.name="Distinct";exports.version="0.1.2";exports.disabled=false;exports.handleSignals=true;exports.group=C.INTERNAL_FUNCTION_GROUP;exports.sync=true;const DEFAULT_MAX_DISTINCT_COMBINATIONS=1e4;const DEFAULT_MAX_DEPTH=15;const{NestedPropertyAccessor}=C.expr;const criblInternalField=C.internal.criblInternalField;let logger;let maxCombinations;let maxDepth;let groupBy;let singleEventProcessor;let distinctCombinations;let root;let knownFields;let hadFinal;let cancelTriggered;exports.init=e=>{const t=e.conf??{};maxCombinations=t.maxCombinations??DEFAULT_MAX_DISTINCT_COMBINATIONS;maxDepth=t.maxDepth??DEFAULT_MAX_DEPTH;let n="";for(let e=0;e<5;++e)n+=String.fromCodePoint("a".charCodeAt(0)+Math.floor(Math.random()*26));logger=C.util.getLogger(`func:distinct`,{funcInstId:n});groupBy=t.groupBy??["*"];if(!Array.isArray(groupBy)||groupBy.length===0||groupBy.length===1&&groupBy[0]==="*"){groupBy=[]}else if(groupBy.length>maxDepth){groupBy=groupBy.splice(0,maxDepth);logger.error("limiting list of specified groupBy fields",{groupBy});throw new Error("distinct function: number of groupBy fields larger than maxDepth configuration value")}switch(groupBy.length){case 0:logger.debug("wildcard mode");singleEventProcessor=buildWildCardDistinct;break;case 1:logger.debug("single groupBy mode");groupBy=new NestedPropertyAccessor(groupBy[0]);singleEventProcessor=buildDistinctSingle;break;default:groupBy=groupBy.map((e=>new NestedPropertyAccessor(e)));logger.debug("multiple groupBy mode",{groupBy});singleEventProcessor=buildDistinctFixed;break}reset()};exports.unload=()=>{groupBy=undefined;root=undefined;knownFields=undefined};exports.process=e=>{if(!e||hadFinal&&e.__signalEvent__!=="reset")return e;if(e.__signalEvent__){logger.debug("signal event received",{event:e.__signalEvent__});switch(e.__signalEvent__){case"reset":reset();return e;case"final":if(hadFinal||e.__ctrlFields?.includes("cancel"))return e;hadFinal=true;case"complete_gen":case"close":return flush(e)}return e}if(distinctCombinations<maxCombinations){singleEventProcessor(e)}else if(!cancelTriggered){logger.debug("reached maxCombinations, canceling query");cancelTriggered=true;const t=e.__clone(false,[]);t.__signalEvent__="cancel";t.__setCtrlField("reason","distinct");return t}};function flush(e){const t=e.__clone(false,[]);t.__signalEvent__="reset";t.__setCtrlField("distinct",e.__signalEvent__??"preview");const n=[t];if(singleEventProcessor===buildWildCardDistinct){flushWildCardDistinct(e.__clone(false,[]),n,root)}else if(singleEventProcessor===buildDistinctFixed){flushDistinctFixed(e.__clone(false,[]),n,root)}else{flushDistinctSingle(e,n)}const i=e.__clone(false,[]);i.__signalEvent__="complete_gen";i.__setCtrlField("distinct","preview");n.push(i);return n}function buildWildCardDistinct(e){if(groupBy.length<maxDepth){for(const t of Object.keys(e).filter((e=>!criblInternalField(e)))){if(!knownFields.has(t)){groupBy.push(t);knownFields.add(t);if(groupBy.length===maxDepth){logger.info("limiting list of dynamically created groupBy fields",{groupBy});break}}}}buildMapPath(e,false)}function buildDistinctFixed(e){const t=buildMapPath(e);const n=mapValue(groupBy[groupBy.length-1].get(e));if(!t.has(n)){++distinctCombinations;t.add(n)}}function buildDistinctSingle(e){root.add(mapValue(groupBy.get(e)));distinctCombinations=root.size}function flushWildCardDistinct(e,t,n,i=0){const o=groupBy[i];if(i<groupBy.length-1){for(const[s,r]of n.entries()){const n=e.__clone(false);n[o]=s;flushWildCardDistinct(n,t,r,i+1)}}else{for(const i of n.keys()){const n=e.__clone(false);n[o]=i;t.push(n)}}}function flushDistinctFixed(e,t,n,i=0){const o=groupBy[i];if(n instanceof Map){for(const[s,r]of n.entries()){const n=e.__clone(false);o.deepSet(n,s);flushDistinctFixed(n,t,r,i+1)}}else{for(const i of n){const n=e.__clone(false);o.deepSet(n,i);t.push(n)}}}function flushDistinctSingle(e,t){for(const n of root){const i=e.__clone(false,[]);groupBy.deepSet(i,n);t.push(i)}}function buildMapPath(e,t=true){let n=root;for(let i=0;i<groupBy.length-(t?1:0);++i){const o=mapValue(t?groupBy[i].get(e):e[groupBy[i]]);let s=n.get(o);if(s==null){s=i<groupBy.length-2?new Map:t?new Set:new Map;n.set(o,s);if(!t&&i===groupBy.length-1){++distinctCombinations}}n=s}return n}function mapValue(e){if(e==null)return null;if(typeof e==="object")return JSON.stringify(e);return e}function reset(){if(singleEventProcessor===buildWildCardDistinct){root=new Map;knownFields=new Set;groupBy=[]}else if(singleEventProcessor===buildDistinctFixed){root=new Map}else{root=new Set}hadFinal=false;cancelTriggered=false;distinctCombinations=0}